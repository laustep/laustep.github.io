[<html>

<head>
  <title>Truncated tesseract</title>
  <style>
    canvas {
      width: 100%;
      height: 100%
    }
  </style>
</head>

<body>
  <!-- <script src="http://mrdoob.github.com/three.js/build/three.min.js"></script> -->
  <script src="../libraries/three.min.js"></script>
  <script src="../libraries/jquery.min.js"></script>
  <script src="../libraries/dat.gui.min.js"></script>

  <script>
    // vertices  -----------------------------------------------------------
    var x = 1 + Math.sqrt(2);
    var r = Math.sqrt(1 + 3 * x * x);
    var vertices = [
      [-1.0, -x, -x, -x],
      [-1.0, -x, -x, x],
      [-1.0, -x, x, -x],
      [-1.0, -x, x, x],
      [-1.0, x, -x, -x],
      [-1.0, x, -x, x],
      [-1.0, x, x, -x],
      [-1.0, x, x, x],
      [1.0, -x, -x, -x],
      [1.0, -x, -x, x],
      [1.0, -x, x, -x],
      [1.0, -x, x, x],
      [1.0, x, -x, -x],
      [1.0, x, -x, x],
      [1.0, x, x, -x],
      [1.0, x, x, x],
      [-x, -1.0, -x, -x],
      [-x, -1.0, -x, x],
      [-x, -1.0, x, -x],
      [-x, -1.0, x, x],
      [-x, 1.0, -x, -x],
      [-x, 1.0, -x, x],
      [-x, 1.0, x, -x],
      [-x, 1.0, x, x],
      [x, -1.0, -x, -x],
      [x, -1.0, -x, x],
      [x, -1.0, x, -x],
      [x, -1.0, x, x],
      [x, 1.0, -x, -x],
      [x, 1.0, -x, x],
      [x, 1.0, x, -x],
      [x, 1.0, x, x],
      [-x, -x, -1.0, -x],
      [-x, -x, -1.0, x],
      [-x, -x, 1.0, -x],
      [-x, -x, 1.0, x],
      [-x, x, -1.0, -x],
      [-x, x, -1.0, x],
      [-x, x, 1.0, -x],
      [-x, x, 1.0, x],
      [x, -x, -1.0, -x],
      [x, -x, -1.0, x],
      [x, -x, 1.0, -x],
      [x, -x, 1.0, x],
      [x, x, -1.0, -x],
      [x, x, -1.0, x],
      [x, x, 1.0, -x],
      [x, x, 1.0, x],
      [-x, -x, -x, -1.0],
      [-x, -x, -x, 1.0],
      [-x, -x, x, -1.0],
      [-x, -x, x, 1.0],
      [-x, x, -x, -1.0],
      [-x, x, -x, 1.0],
      [-x, x, x, -1.0],
      [-x, x, x, 1.0],
      [x, -x, -x, -1.0],
      [x, -x, -x, 1.0],
      [x, -x, x, -1.0],
      [x, -x, x, 1.0],
      [x, x, -x, -1.0],
      [x, x, -x, 1.0],
      [x, x, x, -1.0],
      [x, x, x, 1.0]
    ];
    // edges -------------------------------------------------------------------
    var edges = [
      [0, 8],
      [0, 16],
      [0, 32],
      [0, 48],
      [1, 9],
      [1, 17],
      [1, 33],
      [1, 49],
      [2, 10],
      [2, 18],
      [2, 34],
      [2, 50],
      [3, 11],
      [3, 19],
      [3, 35],
      [3, 51],
      [4, 12],
      [4, 20],
      [4, 36],
      [4, 52],
      [5, 13],
      [5, 21],
      [5, 37],
      [5, 53],
      [6, 14],
      [6, 22],
      [6, 38],
      [6, 54],
      [7, 15],
      [7, 23],
      [7, 39],
      [7, 55],
      [8, 24],
      [8, 40],
      [8, 56],
      [9, 25],
      [9, 41],
      [9, 57],
      [10, 26],
      [10, 42],
      [10, 58],
      [11, 27],
      [11, 43],
      [11, 59],
      [12, 28],
      [12, 44],
      [12, 60],
      [13, 29],
      [13, 45],
      [13, 61],
      [14, 30],
      [14,
        46
      ],
      [14, 62],
      [15, 31],
      [15, 47],
      [15, 63],
      [16, 20],
      [16, 32],
      [16, 48],
      [17, 21],
      [17, 33],
      [17, 49],
      [18, 22],
      [18, 34],
      [18, 50],
      [19, 23],
      [19, 35],
      [19, 51],
      [20, 36],
      [20, 52],
      [21, 37],
      [21, 53],
      [22, 38],
      [22, 54],
      [23, 39],
      [23,
        55
      ],
      [24, 28],
      [24, 40],
      [24, 56],
      [25, 29],
      [25, 41],
      [25, 57],
      [26, 30],
      [26, 42],
      [26, 58],
      [27, 31],
      [27, 43],
      [27, 59],
      [28, 44],
      [28, 60],
      [29, 45],
      [29, 61],
      [30, 46],
      [30, 62],
      [31, 47],
      [31, 63],
      [32, 34],
      [32, 48],
      [33, 35],
      [33,
        49
      ],
      [34, 50],
      [35, 51],
      [36, 38],
      [36, 52],
      [37, 39],
      [37, 53],
      [38, 54],
      [39, 55],
      [40, 42],
      [40, 56],
      [41, 43],
      [41, 57],
      [42, 58],
      [43, 59],
      [44, 46],
      [44, 60],
      [45, 47],
      [45, 61],
      [46, 62],
      [47, 63],
      [48, 49],
      [50, 51],
      [52, 53],
      [54,
        55
      ],
      [56, 57],
      [58, 59],
      [60, 61],
      [62, 63]
    ];
    // tetrahedra --------------------------------------------------------------
    var tetrahedra = [
      [0, 16, 32, 48],
      [11, 27, 43, 59],
      [12, 28, 44, 60],
      [8, 24, 40, 56],
      [9, 25, 41, 57],
      [15, 31, 47, 63],
      [13, 29, 45, 61],
      [14, 30, 46, 62],
      [10, 26, 42, 58],
      [3, 19, 35, 51],
      [2, 18, 34, 50],
      [1, 17, 33, 49],
      [4, 20, 36, 52],
      [5, 21, 37, 53],
      [6, 22, 38, 54],
      [7, 23, 39, 55]
    ];
  </script>

  <script>
    // basic mesh---------------------------------------------------------------
    // problems if R<r but anyway this case is never used by ConeMesh
    function Cmesh0(h, R, r, nstacks, nslices) {
      h = r <= R ? h : -h;
      var ratio = r <= R ? r / R : R / r;
      var k = (ratio - 1) / h;
      // grid ------------------------------------------------------------------
      nstacks = nstacks + 1;
      var u_ = new Array(nstacks);
      for (var i = 0; i < nstacks; i++) {
        u_[i] = h * i / (nstacks - 1);
      }
      var v_ = new Array(nslices);
      for (var i = 0; i < nslices; i++) {
        v_[i] = 2 * Math.PI * i / nslices;
      }
      // vertices & normals ----------------------------------------------------
      Rbig = Math.max(r, R);
      var vertices = new Array(nstacks * nslices);
      var normals = new Array(nstacks * nslices);
      for (var i = 0; i < nstacks; i++) {
        var g = 1 + k * u_[i];
        for (var j = 0; j < nslices; j++) {
          var cosv = Rbig * Math.cos(v_[j]);
          var sinv = Rbig * Math.sin(v_[j]);
          var v = new THREE.Vector3(
            g * cosv,
            g * sinv,
            r <= R ? u_[i] : u_[i] - h // if R<r, cone is upside down...!
          );
          vertices[i * nslices + j] = v;
          var t1 = new THREE.Vector3(
            k * cosv,
            k * sinv,
            1
          );
          var t2 = new THREE.Vector3(
            -v.y, v.x, 0
          )
          normals[i * nslices + j] = t1.cross(t2).normalize().negate();
        }
      }
      // mesh --------------------------------------------------------------------
      var geom = new THREE.Geometry();
      for (var i = 0; i < (nstacks - 1); i++) {
        for (var j = 0; j < nslices; j++) {
          var jp1 = j == nslices - 1 ? 0 : j + 1;
          geom.vertices.push(vertices[i * nslices + j]);
          geom.vertices.push(vertices[i * nslices + jp1]);
          geom.vertices.push(vertices[(i + 1) * nslices + j]);
          geom.faces.push(new THREE.Face3(
            6 * (i * nslices + j),
            6 * (i * nslices + j) + 1,
            6 * (i * nslices + j) + 2,
            [
              normals[i * nslices + j],
              normals[i * nslices + jp1],
              normals[(i + 1) * nslices + j]
            ]
          ));
          geom.vertices.push(vertices[(i + 1) * nslices + j]);
          geom.vertices.push(vertices[i * nslices + jp1]);
          geom.vertices.push(vertices[(i + 1) * nslices + jp1]);
          geom.faces.push(new THREE.Face3(
            6 * (i * nslices + j) + 3,
            6 * (i * nslices + j) + 4,
            6 * (i * nslices + j) + 5,
            [
              normals[(i + 1) * nslices + j],
              normals[i * nslices + jp1],
              normals[(i + 1) * nslices + jp1]
            ]
          ));
        }
      }
      var bufGeom = new THREE.BufferGeometry().fromGeometry(geom);
      var conemesh = new THREE.Mesh(bufGeom,
        new THREE.MeshNormalMaterial({
          side: THREE.DoubleSide
        }));
      return conemesh;
    }
  </script>

  <script>
    // cone mesh -----------------------------------------------------------------
    function ConeMesh(cr1, r1, cr2, r2, nstacks, nslices) {
      if (r2 > r1) {
        return ConeMesh(cr2, r2, cr1, r1, nstacks, nslices);
      }
      var w0 = cr2.sub(cr1);
      var conemesh0 = Cmesh0(w0.length(), r1, r2, nstacks, nslices);
      var w = w0.normalize();
      var wx = w.x;
      var wy = w.y;
      var s = Math.sqrt(w.x * w.x + w.y * w.y);
      if (s == 0) {
        var m = new THREE.Matrix4().set(
          1, 0, 0, cr1.x,
          0, w.z>0 ? 1 : -1, 0, cr1.y,
          0, 0, w.z>0 ? 1 : -1, cr1.z,
          0, 0, 0, 1
        )
        conemesh0.matrix = m;
        conemesh0.matrixAutoUpdate = false;
        return conemesh0;
      }
      var u = new THREE.Vector3(wy / s, -wx / s, 0);
      var v = w.clone().cross(u);
      var m = new THREE.Matrix4().set(
        u.x, v.x, w.x, cr1.x,
        u.y, v.y, w.y, cr1.y,
        u.z, v.z, w.z, cr1.z,
        0, 0, 0, 1
      )
      conemesh0.matrix = m;
      conemesh0.matrixAutoUpdate = false;
      return conemesh0;
    }
  </script>

  <script>
    // functions 4D
    function rightIsoclinic(theta, phi, alpha, x) {
      var x0 = x[0],
        x1 = x[1],
        x2 = x[2],
        x3 = x[3];
      var q0 = Math.cos(alpha);
      var q1 = Math.sin(theta) * Math.cos(phi) * Math.sin(alpha);
      var q2 = Math.sin(theta) * Math.sin(phi) * Math.sin(alpha);
      var q3 = Math.cos(theta) * Math.sin(alpha);
      return [
        q0 * x0 - q1 * x1 - q2 * x2 - q3 * x3, q1 * x0 + q0 * x1 + q3 * x2 - q2 * x3, q2 * x0 - q3 * x1 + q0 * x2 + q1 * x3, q3 * x0 + q2 * x1 - q1 * x2 + q0 * x3
      ];
    }

    function stereo(x, r) {
      return [x[0] / (r - x[3]), x[1] / (r - x[3]), x[2] / (r - x[3])];
    }
  </script>

  <script>
    var Objects = new Array(180);
    for (var i = 0; i < 180; i++) {
      var points = vertices.map(function(vertex) {
        return stereo(rightIsoclinic(0, 0, 2 * i * Math.PI / 180, vertex), r)
      });
      if (i == 0) {
        console.log(points)
      };
      //
      var object = new THREE.Object3D();
      // vertices
      for (var j = 0; j < 64; j++) {
        var geoSphere = new THREE.SphereBufferGeometry(0.1, 16, 16);
        var sphere = new THREE.Mesh(geoSphere, new THREE.MeshNormalMaterial());
        sphere.position.set(points[j][0], points[j][1], points[j][2]);
        object.add(sphere);
      }
      // edges
      for (var j = 0; j < 128; j++) {
        var pt1 = points[edges[j][0]];
        var pt2 = points[edges[j][1]];
        var cr1 = new THREE.Vector3().fromArray(pt1);
        var cr2 = new THREE.Vector3().fromArray(pt2);
        var conemesh = ConeMesh(cr1, 0.07, cr2, 0.07, 3, 30);
        object.add(conemesh);
      }
      // tetrahedra
      for (var j = 0; j < 16; j++) {
        var geoTetrahedron = new THREE.Geometry();
        var indices = tetrahedra[j];
        geoTetrahedron.vertices.push(
          new THREE.Vector3().fromArray(points[indices[0]]),
          new THREE.Vector3().fromArray(points[indices[1]]),
          new THREE.Vector3().fromArray(points[indices[2]])
        );
        geoTetrahedron.faces.push(new THREE.Face3(0, 1, 2));
        geoTetrahedron.vertices.push(
          new THREE.Vector3().fromArray(points[indices[0]]),
          new THREE.Vector3().fromArray(points[indices[1]]),
          new THREE.Vector3().fromArray(points[indices[3]])
        );
        geoTetrahedron.faces.push(new THREE.Face3(3, 4, 5));
        geoTetrahedron.vertices.push(
          new THREE.Vector3().fromArray(points[indices[0]]),
          new THREE.Vector3().fromArray(points[indices[2]]),
          new THREE.Vector3().fromArray(points[indices[3]])
        );
        geoTetrahedron.faces.push(new THREE.Face3(6, 7, 8));
        geoTetrahedron.vertices.push(
          new THREE.Vector3().fromArray(points[indices[1]]),
          new THREE.Vector3().fromArray(points[indices[2]]),
          new THREE.Vector3().fromArray(points[indices[3]])
        );
        geoTetrahedron.faces.push(new THREE.Face3(9, 10, 11));
        var material = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.5,
          side: THREE.DoubleSide
        });
        var tetrahedron = new THREE.Mesh(geoTetrahedron, material);
        object.add(tetrahedron)
      }
      //
      Objects[i] = object;
    }
  </script>

  <script>
    // dat.gui controls --------------------------------------------------------
    var z0 = 5.5;
    var dgcontrols = new function() {
      this.cameraz = 5.5;
      this.rotationSpeed = 25;
    }
    var gui = new dat.GUI({
      autoplace: false,
      width: 300
    });
    gui.add(dgcontrols, 'cameraz').min(1).max(10).step(0.5)
      .name("Camera position");
    gui.add(dgcontrols, 'rotationSpeed').min(0).max(100).step(5)
      .name("Speed of 4D rotation");
  </script>

  <script>
    // three.js scene ---------------------------------------------------
    var scene = new THREE.Scene();
    var aspect = window.innerWidth / window.innerHeight;
    var camera = new THREE.PerspectiveCamera(75, aspect, 1, 10000);
    camera.position.z = z0;
    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    var scene = new THREE.Scene();
    scene.add(camera);
    // render function
    window.requestAnimFrame = (function() {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        function(callback) {
          window.setTimeout(callback, 1000 / 60);
        };
    })();
    var k = 0;

    function render() {
      var object = Objects[k];
      scene.add(object);
      renderer.render(scene, camera);
      //object.rotation.x += dgcontrols.rotationSpeed;
      //object.rotation.y += dgcontrols.rotationSpeed;
      camera.position.z = dgcontrols.cameraz;
      scene.remove(object);
      k += 1;
      if (k == 180) {
        k = 0;
      }
      setTimeout(function() {
        requestAnimationFrame(render);
      }, 1000 / dgcontrols.rotationSpeed);
    }
  </script>

  <script>
    // dragging ----------------------------------------------------------------
    var isDragging = false;
    var previousMousePosition = {
      x: 0,
      y: 0
    };
    $(renderer.domElement).on('mousedown', function(e) {
      isDragging = true;
    }).on('mousemove', function(e) {
      var deltaMove = {
        x: e.offsetX - previousMousePosition.x,
        y: e.offsetY - previousMousePosition.y
      };
      if (isDragging) {
        var deltaRotationQuaternion = new THREE.Quaternion()
          .setFromEuler(new THREE.Euler(
            Math.PI / 180 * (deltaMove.y * .5),
            Math.PI / 180 * (deltaMove.x * .5),
            0,
            'XYZ'
          ));
        for(var i=0; i<180; i++){
          Objects[i].quaternion.multiplyQuaternions(deltaRotationQuaternion,
            Objects[i].quaternion);
        }
      }
      previousMousePosition = {
        x: e.offsetX,
        y: e.offsetY
      };
    });
    $(document).on('mouseup', function(e) {
      isDragging = false;
    });
  </script>


  <script>
    render();
  </script>
</body>

</html>
