<html>

<head>
  <title>Clifford torus</title>
  <style>
    canvas {
      width: 100%;
      height: 100%
    }
  </style>
</head>

<body>
  <script src="three.min.js"></script>
  <script src="jquery.min.js"></script>

  <script> // vertices and edges -----------------------------------------------
    var vs = [
      [-0.5, -0.5, -0.5, -0.5],
      [-0.5, -0.5, -0.5, 0.5],
      [-0.5, -0.5, 0.5, -0.5],
      [-0.5, -0.5, 0.5, 0.5],
      [-0.5, 0.5, -0.5, -0.5],
      [-0.5, 0.5, -0.5, 0.5],
      [-0.5, 0.5, 0.5, -0.5],
      [-0.5, 0.5, 0.5, 0.5],
      [0.5, -0.5, -0.5, -0.5],
      [0.5, -0.5, -0.5, 0.5],
      [0.5, -0.5, 0.5, -0.5],
      [0.5, -0.5, 0.5, 0.5],
      [0.5, 0.5, -0.5, -0.5],
      [0.5, 0.5, -0.5, 0.5],
      [0.5, 0.5, 0.5, -0.5],
      [0.5, 0.5, 0.5, 0.5],
    ];
    var edges = [
      [0, 1], [0, 2], [0, 4], [0, 8], [1, 3], [1, 5], [1, 9], [2, 3], [2, 6],
      [2, 10], [3, 7], [3, 11], [4, 5], [4, 6], [4, 12], [5, 7], [5, 13],
      [6, 7], [6, 14], [7, 15], [8, 9], [8, 10], [8, 12], [9, 11], [9, 13],
      [10, 11], [10, 14], [11, 15], [12, 13], [12, 14], [13, 15], [14, 15]
    ];
  </script>

  <script> // draw a cylinder --------------------------------------------------
    function cylindricalSegment(A, B, radius, material) {
      var vec = B.clone(); vec.sub(A);
      var h = vec.length();
      vec.normalize();
      var quaternion = new THREE.Quaternion();
      quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), vec);
      var geometry = new THREE.CylinderGeometry(radius, radius, h, 24);
      geometry.translate(0, h / 2, 0);
      var cylinder = new THREE.Mesh(geometry, material);
      cylinder.applyQuaternion(quaternion);
      cylinder.position.set(A.x, A.y, A.z);
      return cylinder;
    }
  </script>

  <script> 
    // stereographic projection ------------------------------------------------
    function stereog(x) {
      var r = Math.acos(x[3]) / Math.PI / Math.sqrt(1 - x[3] * x[3])
      return new THREE.Vector3(x[0] * r, x[1] * r, x[2] * r);
    }

    // rotation in 4D space (right-isoclinic) ----------------------------------
    function rotate4d(alpha, beta, xi, vec) {
      var a = Math.cos(xi);
      var b = Math.sin(alpha) * Math.cos(beta) * Math.sin(xi);
      var c = Math.sin(alpha) * Math.sin(beta) * Math.sin(xi);
      var d = Math.cos(alpha) * Math.sin(xi);
      var p = vec[0]; var q = vec[1]; var r = vec[2]; var s = vec[3];
      return [
        a * p - b * q - c * r - d * s,
        a * q + b * p + c * s - d * r,
        a * r - b * s + c * p + d * q,
        a * s + b * r - c * q + d * p
      ];
    }
  </script>

  <script>
    var alpha = 0;
    var beta = 0;
    var xi = 0;
  </script>

  <script> // three.js scene
    var scene = new THREE.Scene();
    var aspect = window.innerWidth / window.innerHeight;
    var camera = new THREE.PerspectiveCamera(75, aspect, 1, 10000);
    camera.position.z = 1.95;
    scene.add(camera);

    var object = new THREE.Object3D();
    scene.add(object);

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    var material = new THREE.MeshNormalMaterial({ wireframe: false });

  </script>

  <script> // mouse dragging ---------------------------------------------------
    var isDragging = false;
    var previousMousePosition = { x: 0, y: 0 };
    $(renderer.domElement).on('mousedown', function (e) {
      isDragging = true;
    }).on('mousemove', function (e) {
      var deltaMove = {
        x: e.offsetX - previousMousePosition.x,
        y: e.offsetY - previousMousePosition.y
      };
      if (isDragging) {
        var deltaRotationQuaternion = new THREE.Quaternion()
          .setFromEuler(new THREE.Euler(
            Math.PI / 180 * (deltaMove.y * 1),
            Math.PI / 180 * (deltaMove.x * 1),
            0,
            'XYZ'
          ));
        object.quaternion.multiplyQuaternions(deltaRotationQuaternion,
          object.quaternion);
      }
      previousMousePosition = {
        x: e.offsetX,
        y: e.offsetY
      };
    });

    $(document).on('mouseup', function (e) {
      isDragging = false;
    });

    window.requestAnimFrame = (function () {
      return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        function (callback) {
          window.setTimeout(callback, 1000 / 60);
        };
    })();

    var edgeMeshes = [];
    function render() {
      renderer.render(scene, camera);

      //scene.remove(object);

      object.children.forEach(c => { c.geometry.dispose(); object.remove(c) });
      //edgeMeshes.forEach(e => { e.geometry.dispose(); scene.remove(e) });
      //edgeMeshes = [];

      var vs3 = [];
      for (var i = 0; i < vs.length; i++) {
        vs3.push(stereog(rotate4d(alpha, beta, xi, vs[i])));
      }
      for (var i = 0; i < vs3.length; i++) {
        var geometry = new THREE.SphereBufferGeometry(0.05, 24, 24);
        geometry.translate(vs3[i].x, vs3[i].y, vs3[i].z);
        var mesh = new THREE.Mesh(geometry, material);
        object.add(mesh);
        //edgeMeshes.push(mesh);
      }
      for (var i = 0; i < edges.length; i++) {
        var mesh = cylindricalSegment(
          vs3[edges[i][0]], vs3[edges[i][1]],
          0.025, material);
        object.add(mesh);
        //edgeMeshes.push(mesh);
      }

    //scene.add(object);

      object.rotation.x += 0.001;
      object.rotation.y += 0.001;
      xi += 0.005;

      requestAnimFrame(render);
    }

    render();
    //renderer.animate( render )
  </script>

</body>

</html>